% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/conc_by_tag.R
\name{conc_by_tag}
\alias{conc_by_tag}
\title{Concordance Text By Tag Choices}
\usage{
conc_by_tag(
  data,
  what = "token",
  tag = "mda",
  match,
  cols = NULL,
  tag2 = NULL,
  match2 = NULL,
  ...
)
}
\arguments{
\item{data}{A relational data frame containing the text to concordance.
The data frame is expected to have one column of tokens, in tokenized form, at least one
column of the corresponding tags, and identifying details such as corpus, doc_id etc.}

\item{what}{The name of the column containing the text to concatenate. Default is "token".}

\item{tag}{The name of the column containing the tags to match. Default is "mda".}

\item{match}{The tag to match within the \code{tag} column. The match can take regex, so you can use
anchoring characters (^ and $) for specific searches.}

\item{cols}{The names of the columns to include in the output. It may be useful to include some
extra reference columns (such as doc_id), or other tags for more fine-grained filtering.}

\item{tag2}{The name of the second column containing the tags to match (optional).}

\item{match2}{The second tag to match within the \code{tag2} column (optional).}

\item{...}{Additional arguments to be passed onto \code{dtagger::quick_conc}.

For example:
pass on the \code{separated = TRUE} argument, to enable sorting search result by
adjacent tokens to the left and right

pass on the \code{n = 3 }argument, to limit the search window to 3 tokens either side of the match.}
}
\value{
A tibble containing:
\itemize{
\item case - a case number for the match found.
\item left - objects immediately adjacent (up to n) to the left of the matched node,
as defined by the \code{what} argument (default is token).
In case of \code{separated = TRUE}, the left  are separated into left(n):left1
\item match - the matched search item, as defined by the \code{match} argument.
\item right - tokens immediately adjacent (up to n) to the right of the matched node,
as defined by the \code{what} argument (default is token).
In case of \code{separated = TRUE}, the right tokens are separated into right1:right(n).
\item index - the index row position of matched result from the input data frame.
\item other cols - as defined by the \code{tag}, \code{tag2} and \code{cols} arguments.
}
}
\description{
This function produces concordance lines of text from \code{data} by finding up to
two tag matches in tokenized text.
}
\details{
The purpose of this function is to allow fine-grained concordance searches of tagged text.
The input should be a dataframe with a column for tokens in tokenized form,
and separate columns for tags, document and corpus details.

Typically, the function can be used with output from \code{udpipe::udpipe_annotate}
and \code{dtagger::dtag_tbl}, \code{dtagger::dtag_directory} or \code{dtagger::add_tag_tbl} functions.

The concordancer can take up to two tag inputs, for example matching all \code{upos == "ADJ"}
tags and \code{dep_rel == "amod"} tags, and seing the resulting key words in context.
}
\examples{
\dontrun{
# Load the required udpipe model
Load the required udpipe model
init_udpipe_model()

# Process text with the add_tag_tbl function (assuming add_mda_tags function is defined)
text <- c(doc1 = "This is a simple sentence with a specific keyword.",
          doc2 = "Is this one more complex or simpler?")
data <- add_tag_tbl(text)

# Run conc_by_tag function with specified tags and matches
conc_by_tag(
  data,
  what = "token",
  tag = "xpos",
  match = "^JJ$",
  cols = c("doc_id", "lemma"),
  tag2 = "dep_rel",
  match2 = "^amod$"
)
conc_by_tag(
  data,
  what = "token",
  tag = "xpos",
  match = "JJ",
  cols = c("doc_id", "dep_rel"),
  separated = TRUE,
  n = 3
)
}
}
